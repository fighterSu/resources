# 数据库学习笔记

## 常见概念解析

### DB、DBMS、SQL

1. DB**（DataBase） 数据库**：以文件形式在磁盘上存在，一般是后缀名为 .db 的文件
2. DBMS **（DataBase Management System） 数据库管理系统**：常见的有MySQL、Oracle、DB2等 
3. SQL **（Structured Query Language）结构化查询语言**：是一门标准通用化语言。标准MySQL适合所有数据产品。是一门高级语言，先编译再执行，由 DBMS 进行编译。

**三者之间的关系：DBMS 执行SQL语句，并通过执行 SQL 语句来操作 DB 之中的数据**




学习过程**以 MySQL 为学习软件**，会使用一些 **MySQL 命令**，需要注意的是，**这些命令不是SQL语句，在其它数据库管理系统上无法使用**



### 表的概念

**定义：table 是数据库的基本组成单元，以表格形式组织，目的是可读性强**

**行：数据（data）；表中的一条记录**

**列：字段（column），包含字段名、数据类型、以及字段相关的约束**

![image-20210822101301134](https://gitee.com/fighterSu/resources/raw/image/typora/202108221013215.png)



### SQL语句的分类

1. 数据查询语言（DQL）
   数据查询语言（Data Query Language, DQL）是SQL语言中，负责进行数据查询而不会对数据本身进行修改的语句，这是最基本的SQL语句。保留字**SELECT**是DQL（也是所有SQL）用得最多的动词，其他DQL常用的保留字有**FROM，WHERE，GROUP BY，HAVING和ORDER BY**。这些DQL保留字常与其他类型的SQL语句一起使用。

2. 数据定义语言（DDL）
   数据定义语言 (Data Definition Language, DDL) 是SQL语言集中，负责数据结构定义与数据库对象定义的语言，由**CREATE、DROP与ALTER**三个语法所组成，分别代表**新建，删除，改变结构**。最早是由 Codasyl (Conference on Data Systems Languages) 数据模型开始，现在被纳入 SQL 指令中作为其中一个子集。

3. 数据操纵语言（DML）
   数据操纵语言（Data Manipulation Language, DML）是SQL语言中，负责对数据库对象运行数据访问工作的指令集，以**INSERT、DELETE、UPDATE**三种指令为核心，分别代表**插入、删除与更新**。

4. 数据控制语言（DCL）
   数据控制语言 (Data Control Language) 在SQL语言中，是一种可**对数据访问权进行控制**的指令，它可以**控制特定用户账户**对**数据表、查看表、预存程序、用户自定义函数等数据库对象的控制权**。由 GRANT 和 REVOKE 两个指令组成。DCL以控制用户的访问权限为主，GRANT为授权语句，对应的REVOKE是撤销授权语句。

5. 事务处理语言（TCL）

   事务处理语言（Transaction Control Language，TCL），它的语句能确保被DML语句影响的表的所有行及时得以更新。TPL语句包括BEGIN TRANSACTION，COMMIT和ROLLBACK。





## 数据库初始化

1. **登录MySQL**    在CMD或者其它终端使用MySQL命令 **mysql -u用户名 -p密码** 这里是输入**明文密码**，若要输入密文密码，**在 -p 之后回车输入密码即为密文密码**![image-20210822104436749](https://gitee.com/fighterSu/resources/raw/image/typora/202108221044848.png)

2. **查看现有数据库 MySQL命令** ：**show database;** 注意有个英文分号;结束语句
      ![image-20210822104645009](https://gitee.com/fighterSu/resources/raw/image/typora/202108221046058.png)
      
3. **新建数据库**    **create database 数据库名;**
      ![image-20210822104828661](https://gitee.com/fighterSu/resources/raw/image/typora/202108221048703.png)
      
4. **切换数据库    use 数据库名;**
      ![image-20210822104939344](https://gitee.com/fighterSu/resources/raw/image/typora/202108221049388.png)
      
5. **查看数据库之中的表格**  查看**当前使用数据库**表格: **show tables;**  
                                   其它数据库： **show tables from 数据库名;** 
      
6. **执行sql脚本初始化数据  source sql脚本文件绝对路径（一般直接把脚本文件拖进终端窗口获取）**
      ![image-20210822105633294](https://gitee.com/fighterSu/resources/raw/image/typora/202108221056331.png)

      ![image-20210822111912081](https://gitee.com/fighterSu/resources/raw/image/typora/202108221119130.png)

      ![image-20210822111958338](https://gitee.com/fighterSu/resources/raw/image/typora/202108221119377.png)

## 使用数据库

1. **查看表结构 **  **desc 表名;**  description
      ![image-20210822115815511](https://gitee.com/fighterSu/resources/raw/image/typora/202108221158561.png)
2. **查看表内容**  **select * from 表名** **查看表格指定列数据  使用“*”则显示所有列，可以一次查询多列，列名之间以","号分隔开**
      ![image-20210822121659288](https://gitee.com/fighterSu/resources/raw/image/typora/202108221216351.png)





## MySQL常用命令

### 查询当前正在使用的数据库

select database;    select 查询指令（DQL语句）

![image-20210822124505698](https://gitee.com/fighterSu/resources/raw/image/typora/202108221245755.png)

### 查询MySQL版本

**mysql --version**

**mysql -V**



### 终止一条语句

**如果想要终止一条正在编写的语句，可以输入 \C**



### 退出MySQL

**使用 \q ,quit，或者exit;**

**以及快捷键 Ctrl  + C** 





### 查看创建表的语句

**show create table 表名**

![image-20210822152349297](https://gitee.com/fighterSu/resources/raw/image/typora/202108221523360.png)







## select 语句 简单查询

**用法：**

```sql
select 字段一、字段二、字段三... （(as) 别名） from 表名 where 条件
```



1. **可以使用 \* 来代表所有字段，但只在日常学习之中使用，不会在开发之中使用，原因是这样效率比较低**
   ![image-20210824161842368](https://gitee.com/fighterSu/resources/raw/image/typora/202108241618419.png)
2. **查询出来的字段可以进行数学运算以及重命名，用法： 字段名 （数学运算） (as) 别名**
   ![image-20210824162415550](https://gitee.com/fighterSu/resources/raw/image/typora/202108241624615.png)![image-20210824162528530](https://gitee.com/fighterSu/resources/raw/image/typora/202108241625609.png)
3. **SQL语句不区分大小写，但最好有个规范，为了好看**
   ![image-20210824162649262](https://gitee.com/fighterSu/resources/raw/image/typora/202108241626316.png)
4. **SQL语句可以分开多行写，但每行需要是完整单词，不能出现形如 一个单词分割开来在不同行**

![image-20210824161755364](https://gitee.com/fighterSu/resources/raw/image/typora/202108241618485.png)



## where 条件语句

用法：

```sql
select 字段1，字段2... from 表名 where 条件
select ename,sal from emp  where sal > 3000;
```

**条件查询需要用到where语句，where必须放到from语句表的后面**

**支持如下运算符**

| 运算符           | 说明                                                         |
| ---------------- | ------------------------------------------------------------ |
| =                | 等于                                                         |
| <>或!=           | 不等于                                                       |
| <                | 小于                                                         |
| <=               | 小于等于                                                     |
| >                | 大于                                                         |
| >=               | 大于等于                                                     |
| between … and …. | 两个值之间,**等同于 >= and <=**  between x and y  <==>  [x,y]  (x < y)，这里x，y可以是数字也可以是字符，但一般不用于字符 |
| is null          | 为null（is not null 不为空）                                 |
| **and**          | 并且                                                         |
| **or**           | 或者                                                         |
| in               | 包含，相当于多个or（not in不在这个范围中）                   |
| not              | not可以取非，主要用在is 或in中                               |
| like             | like称为模糊查询，支持%或下划线匹配  %匹配任意个字符  下划线，一个下划线只匹配一个字符 |



**注意事项：**

1. **数据库之中NULL不是一个值，代表为空，什么也没有，不能用等号进行比较，必须使用 is null 或者 is not null 来进行比较**，但**插入数据时**，如果**一个项为NULL**，那么**需要使用null填充，而不能留空**

   ![image-20210824221901130](https://gitee.com/fighterSu/resources/raw/image/typora/202108242230674.png)

2. **SQL语句之中，字符串类型为 varchar类型 使用单引号括起来表示'字符串'，**仅在MySql之中支持双引号表示字符串，故不推荐使用双引号表示字符串
   ![image-20210825083226512](https://gitee.com/fighterSu/resources/raw/image/typora/202108250832566.png)

3. between … and ….  查询位于两个值之间数据， **between x and y  <==>  [x,y]  (x < y)**，
   这里**x，y可以是数字也可以是字符，但一般不用于字符，用于字符时查询结果是[x，y)区间**

![image-20210825083558486](https://gitee.com/fighterSu/resources/raw/image/typora/202108250835536.png)
![image-20210825083646596](https://gitee.com/fighterSu/resources/raw/image/typora/202108250840604.png)
![image-20210825083718052](https://gitee.com/fighterSu/resources/raw/image/typora/202108250840724.png)



4. **and 和 or 同时使用时，and优先级比较高，当运算符优先级不确定，想某一块先执行，放进小括号里面**
   **例子：找出薪资大于1000的并且部门编号是20或30部门的员工。**

   ```sql
   # 错误示例
   select ename,sal from emp where sal > 1000 and deptno=20 or deptno = 30;
   # 这样会将后面条件解释成   (sal>1000 and deptno=20) or deptno=30
   # 正确示例
   select ename,sal from emp where sal > 1000 and (deptno=20 or deptno = 30);
   # 总之优先级不确定就加小括号
   ```

5. **字段 in (选项1，选项2，选项三...) <==>  字段=选项1 or  字段=选项2 or 字段=选项3，特别注意当只有两个选项并且都是数字时注意不是范围在这两个数字之间的数据**
   ![image-20210825100743374](https://gitee.com/fighterSu/resources/raw/image/typora/202108251007449.png)



6. **like 关键字用于模糊搜索，有两个特殊符号， 下划线'\_'表示任意一个字符，百分号%代表任意多个字符**
   使用场景：

   1. 查询 **包含字符x** 的数据  **like '%x%'**
   2. 查询以形式为 **ab某c** 的数据 **like  'ab_c'**

   **特殊情况：查询包含‘\_’或者‘%’的数据，使用\进行转义**

   1. 查询 **包含‘\_’**的数据    **like '%\\\_%'**
   2. 查询 **包含‘%’**的数据    **like '%\%%'**



## 排序语句

**关键字：order by 字段一 desc(降序) | asc(升序,默认) ，字段二(...)，字段三(...)... **

原则：**by 后面**的**字段越靠前**，起的**主导作用越大**，**当字段一相同时，再按字段二比较**，同理再看字段三，可以**在字段后面**使用 **<u>desc</u> 关键字指定降序**，**使用 <u>asc</u> 指定升序**，默认是升序，**可以不用使用 asc**

```sql
select
  ename, sal
from
  emp
order by sal desc, ename asc; # 首先按照薪资降序排，薪资相同时按照名字升序排
# 查询结果如下
# ename       sal  
# ------  ---------
# KING      5000.00
# FORD      3000.00 薪资相同，按照名字升序排，F > S
# SCOTT     3000.00
# JONES     2975.00
```

**有个~~不推荐~~的写法：主要是健壮性太差，不允许以后写在代码里面**

```sql
select
  ename, sal
from
  emp
order by 2; # 按照select 后面的字段序号来排列，这里select后面第二个字段为 sal，这里是按照sal			   # 默认排序的意思
# 结果如下：
# ename       sal  
# ------  ---------
# SMITH      800.00
# JAMES      950.00
# ADAMS     1100.00
# WARD      1250.00
```



## 分组函数

**分组函数也叫多行处理函数，意思是：对某一组数据进行处理最后输出一行结果**

同理有单行处理函数，只能一行一行执行。



### 包含的函数

| **函数名**      | **函数作用**                                                 |
| --------------- | ------------------------------------------------------------ |
| **count(字段)** | **统计字段之中不为 NULL 的元素个数；<br />需要注意，count(*)与字段无关，查询结果是表中记录的个数** |
| **sum(字段)**   | **获取字段数值元素总和**                                     |
| **avg(字段)**   | **获取字段数组数据的平均值**                                 |
| **max(字段)**   | **获取字段数据之中的最大值**                                 |
| **min(字段)**   | **获取字段数据之中的最小值**                                 |



**注意：分组函数自动忽略空值，不需要手动的加where条件排除空值。**

**select count(\*) from emp where xxx;            符合条件的所有记录总数。**

**select count(comm) from emp;     comm这个字段中不为空的元素总数。**



**特别注意：不能在where语句之中使用分组函数，原理见后面讲解，主要是分组函数是在分组之后才能执行的，而where语句的执行又在分组之前完成，所以不能在where语句之中使用分组函数**



**关于格式化SQL语句的一点问题：在使用分组函数时函数名和括号之间不能有空格，不然会解析成数据库函数，从而造成错误。**



### 分组函数可以组合使用

```sql
select
  count (*), count (comm), sum (sal), avg (sal), max (sal), min (sal)
from
  emp;
# 查询结果如下
# count(*)  count(comm)  sum(sal)     avg(sal)  max(sal)  min(sal)  
# --------  -----------  --------  -----------  --------  ----------
#       14            4  29025.00  2073.214286   5000.00      800.00

# 可以看到：
# count(*)查询出了emp表中记录的条数
# 而count(comm)统计出了字段comm之中，非NULL元素有四个
```



### 特殊情况

**SQL运算之中的原则：只要运算之中出现NULL，结果必然也为NULL**

所以在某些**允许NULL的字段上**需要注意此问题，同时这里介绍一个ifnull()语法

语法格式：**ifnull(可能为空的数据，被当作什么处理)**

下面我们来看一个例子

```sql
# 查询员工年薪，要求包含津贴 comm 字段进行计算
# 员工ename、月工资sal，津贴comm数据如下
# 员工     月工资      月津贴  
# ------  ---------  -----------
# SMITH      800.00       (NULL)
# ALLEN     1600.00       300.00
# WARD      1250.00       500.00
# JONES     2975.00       (NULL)
# 错误示例
select
  ename '员工', (sal + comm) * 12 '年薪'
from
  emp;
# 查询结果
# 员工    年薪  
# ------  ----------
# SMITH       (NULL)
# ALLEN     22800.00
# WARD      21000.00
# JONES       (NULL)
# 结果分析，年薪出现NULL，明显查找语句出现了问题，
# 这里主要是comm字段有NULL参与了数学运算，造成结果为NULL

# 正确语句
select
  ename '员工', (sal + ifnull(comm,0)) * 12 '年薪' 
                     # ifnull(comm,0)，如果comm为NULL，则用0参与运算
from
  emp;
# 查询结果
# 员工    年薪  
# ------  ----------
# SMITH      9600.00
# ALLEN     22800.00
# WARD      21000.00
# JONES     35700.00
# 可以看到这次运算结果是正确的
```







## 分组及分组后再过滤

**group by**：对**某个**字段或者**某些**字段进行**分组**

   **having**：对**分组后**的数据进行**再过滤**



### 主要语法

```sql
#语句  执行次序
select   5
	...
from	 1
	...
where	 2
	...
group by 3
	...  # 起码在这才能使用 分组函数，所以分组函数不能用于 where 语句之中
having	 4     # 必须有group by 语句进行分组才能使用 having 语句，不允许脱离group by语句
	...
order by 6
	...
	
```

**注意事项：当使用 group  by 进行了分组，select  后面只能加参与了分组的字段或者分组函数，其它的没有意义**

```sql
select
    ename, deptno '部门编号', max(sal) '最高薪资' 
    # 这里 ename 没有参与分组，所以ename的查询结果无意义
from
  emp
group by deptno;
# 查询结果
# ename   部门编号  最高薪资  
# ------  ------------  --------------
# CLARK             10         5000.00
# SMITH             20         3000.00
# ALLEN             30         2850.00

# 可以看到，查询出的ename字段的三个数据仅仅是取了前三个，没有什么意义
```



### 使用实例

```sql
# 要求找出每个部门的最高工资
select
  deptno '部门编号', max(sal) '最高薪资'
from
  emp
group by deptno; 

# 要求找出每个岗位的最高工资
select
    job '工资岗位', max(sal) '最高薪资'
from
  emp
group by job;

# 当没有使用 group by 语句时，整张表自成一组，可以使用分组函数
# 要求找出所有员工的最高工资及平均工资
select 
   max(sal),avg(sal)
from
   emp;
   
# 找出工资比平均工资高的员工
# 错误示例
select
  ename, sal
from
  emp
where sal > avg(sal); # 一定要注意，分组函数要在分组后才能使用，而where语句是在分组之前执行的

# 正确步骤，拆解问题
# 1. 得到平均工资
select avg(sal) from emp;
# 2. 查询工资比平均工资高的员工
select ename,sal from emp where sal>平均工资;
# 3. 联合两个语句
select ename,sal from emp where sal>(select avg(sal) from emp);
# 这里使用了子查询，以后会讲解
```



 

### 多个字段分组

案例：**找出每个部门不同工资岗位的最高薪资**

```sql
# group by 后面加多个字段就是把两个字段连接在一起看成一个字段分组
# 找出每个部门不同工资岗位的最高薪资
# 拆解问题
# 1. 找出每个部门的不同工作岗位
select deptno,job from emp group by deptno,job;
# 2. 查找最高工资
select deptno,job,max(sal) from emp group by deptno,job;

# 查询结果
-- deptno  job        max(sal)
-- ------  ---------  ----------
--     10  CLERK         1300.00
--     10  MANAGER       2450.00
--     10  PRESIDENT     5000.00
--     20  ANALYST       3000.00
--     20  CLERK         1100.00
--     20  MANAGER       2975.00
--     30  CLERK          950.00
--     30  MANAGER       2850.00
--     30  SALESMAN      1600.00
# 可以看到是部门编号和工资岗位链接在一起看成一个字段
```



### having 的使用

**前提条件：使用了group by 语句进行分组**

添加位置：group by 后面，order  by 前面，对**分组后**的数据进行**再过滤**



案例1：**找出每个岗位最高薪资，要求显示薪资大于2900的数据**

```sql
# having 是对分组后的数据进行再过滤
# 问题拆解
# 1. 找到各个岗位最高薪资
select job,max(sal) from emp group by job;
# 2. 显示最高薪资大于2900的数据
select job,max(sal) from emp group by job having max(sal)>2900;
# 使用having 效率比较低，原因是分组后才进行过滤，而where是先筛选一遍再分组，分组的元素少
# 所以一般能用where就用where
select job,max(sal) from emp where sal > 2900 group by job;

# 但如果必须使用having，那就用
# 案例2：找出每个岗位平均薪资，显示平均薪资大于2000的数据
select job,avg(sal) from emp group by job having avg(sal)>2000;

# 看能不能用where 主要看目标比较数据是否是已经存在的，
#  比如案例1之中，最高薪资也是已经存在的工资里面的，
#  案例2的平均薪资需要使用分组函数计算，所有不能使用where语句过滤
```

**使用having 效率比较低，原因是分组后才进行过滤，而where是先筛选一遍再分组，分组的元素少**
**所以一般能用where就用where**





## 去除重复记录查询

**关键字：distinct  字段一、字段二...**

distinct 关键字**必须加在select 后面**，后面**有多个字段**，则**将多个字段联合在一起看作一个字段去除重复记录**

```sql
select job from emp;
# 查询结果：
# job        
# -----------
# CLERK      
# SALESMAN   
# SALESMAN   
# MANAGER    
# SALESMAN   
# MANAGER    
# MANAGER    
# ANALYST    
# PRESIDENT  
# SALESMAN   
# CLERK      
# CLERK      
# ANALYST    
# CLERK 
# 有重复记录

select distinct job from emp;
# job        
# -----------
# CLERK      
# SALESMAN   
# MANAGER    
# ANALYST    
# PRESIDENT  
# 无重复记录

# 多个字段使用 distinct 关键字
select deptno,job from emp order by deptno;
# 查询结果
# deptno  job       
# ------  ----------- 
#     10  CLERK       
#     10  PRESIDENT  
#     10  MANAGER    
#     20  ANALYST    
#     20  CLERK      
#     20  ANALYST    
#     20  MANAGER    
#     20  CLERK      
#     30  MANAGER    
#     30  SALESMAN   
#     30  SALESMAN   
#     30  SALESMAN   
#     30  CLERK      
#     30  SALESMAN
# 可以看到，将deptno和job连接在一起看作同一个字段的话，上面的结果是存在重复的

select distinct deptno,job from emp order by deptno;

# 查询结果
# deptno  job        
# ------  -----------
#     10  CLERK      
#     10  MANAGER    
#     10  PRESIDENT  
#     20  ANALYST    
#     20  CLERK      
#     20  MANAGER    
#     30  CLERK      
#     30  MANAGER    
#     30  SALESMAN   
# 相比上面的结果，明显对于这两个字段的拼接”新字段“，是没有重复记录的
```





## 连接查询

**定义：多张表联合查询取出最后结果**

为什么要使用多张表？

对于某些场景，经常碰到相同数据的情况

比如如果将学生信息和班级信息存在同一张表之中，那么就会出现下面这种情况

| 学号 | 姓名 | 班级编号 | 班级名称                   |
| ---- | ---- | -------- | -------------------------- |
| 001  | 张三 | 0001     | 广州白云区海淀第七十三中学 |
| 002  | 李四 | 0001     | 广州白云区海淀第七十三中学 |
| 003  | 王五 | 0001     | 广州白云区海淀第七十三中学 |

可以看到，表格之中出现的班级信息都一样，这样就会造成**信息冗余**，所以**我们需要掌握连接查询**



### 分类

1. 按语法出现的年代划分：SQL92(比较老，用的比较少了)，SQL99（比较新，用的比较多）
2. 根据表的连接方式来划分
   1. 内连接
      1. 等值连接
      2. 非等值连接
      3. 自连接
   2. 外连接
      1. 左外连接（左连接）：在 jion 关键字左边的是主表
      2. 右外连接（右连接）：在 jion 关键字右边的是主表



### 笛卡尔积现象

#### 笛卡尔积

A = {0,1}   B = {2,3,4}

集合 A×B 和 B×A的结果集就可以分别表示为以下这种形式：

A×B = {（0，2），（1，2），（0，3），（1，3），（0，4），（1，4）}；

B×A = {（2，0），（2，1），（3，0），（3，1），（4，0），（4，1）}；

以上A×B和B×A的结果就可以叫做两个集合相乘的‘笛卡尔积’。



**数据库表连接数据行匹配时所遵循的算法就是以上提到的笛卡尔积，表与表之间的连接可以看成是在做乘法运算。**

**笛卡尔积现象：当两张表进行连接查询的时候，没有限制，最终查询结果是两张表记录总数的乘积**

```sql
select ename from emp;
# 查询结果有 4 条
select dname from dept;
# 查询结果有 14 条
select ename,dname from emp,dept;
# 字段放在一起意味着把两个字段粘在一起显示
# 查询结果有 4*14=56 条，即ename和dname各自查询结果的笛卡尔积
# ename   dname       
# ------  ------------
# SMITH   ACCOUNTING  
# SMITH   RESEARCH    
# SMITH   SALES       
# SMITH   OPERATIONS  
# ALLEN   ACCOUNTING  
# ALLEN   RESEARCH    
# ALLEN   SALES       
# ALLEN   OPERATIONS  
......

# 造成笛卡尔积现象的原因是：对于查询没有设置条件

```

**避免笛卡尔积现象：给连接查询设置条件**

这里需要注意一个点，设置了条件，会减少数据的匹配次数吗?

**不会，匹配次数还是56次，只是只显示了有效记录**





### 连接语句基础写法

先看一个demo

```sql
# 没有别名的写法
select
	ename,grade
from
	emp,salgrade;
	
# 有别名的写法
select
	e.ename,s.grade
from
	emp e,salgrade s;
```

**给表起别名**

1. **必要性：不同的表可能存在同名的字段，需要表名进行区分，而有些表名比较长，书写程序不方便**
2. **优点：**
   1. **执行效率高：在上面那个demo之中，没有别名的写法之中，查找ename字段不仅会到emp表之中查，也会到grade表之中去差；而有了别名，就只在对应表之中查找，大大提高效率**
   2. **可读性强：能够清楚的看出来哪个字段是哪个表的，清晰明了**



### 等值连接：

**最大特点：条件是等值条件**

案例：**找出每个员工的部门，要求显示员工名以及部门名称**

SQL92语法（太老了，不用了）

```sql
select
  e.ename, d.dname
from
  emp e, dept d
where e.deptno=d.deptno;
```

SQL99语法（常用）

```sql
select
  e.ename, d.dname
from
  emp e
  # 这里使用的是内查询，inner关键字可以省略，以后外查询outer关键字一样可以省略
  # (inner) join dept d
  join dept d
    on e.deptno = d.deptno;
```



**SQL99语法更加清晰，将表的连接条件和where语句分离了**





### 非等值连接：

**最大特点：条件不是等值条件**

案例：**找出每个员工的薪资等级，要求显示员工名以及薪资水平**


```sql
select
  e.ename, s.grade
from
  emp e
  join salgrade s
    on e.sal between s.losal and s.hisal;
    
# 查询结果
# ename    grade  
# ------  --------
# SMITH          1
# ALLEN          3
# WARD           2
# JONES          4
```



### 自连接

**特点：一张表看作两张表，自己连自己**

案例：**找每个员工的上级领导（没有领导的不用显示)**

```sql
select
  e1.ename '员工', e2.ename '领导'
from
  emp e1
  join emp e2
    on e1.mgr = e2.empno
order by e1.ename;
    
# 这里给表起了两个别名，这就是自连接，同一张表当作两张表使用
# 查询结果
# 员工     领导  
# ------  --------
# ADAMS   SCOTT   
# ALLEN   BLAKE   
# BLAKE   KING    
# CLARK   KING    
# FORD    JONES   
# JAMES   BLAKE   
# JONES   KING    
# MARTIN  BLAKE   
# MILLER  CLARK   
# SCOTT   JONES   
# SMITH   FORD    
# TURNER  BLAKE   
# WARD    BLAKE   


# 细心的同学会发现 KING 没有出现在员工字段里面，这是因为他的  deptno 是 NULL
```





### 外连接

#### 外连接与内连接的区别

**内连接：A，B表进行连接，凡是A表和B表能够匹配的记录查询出来**

**外连接：A，B之间有一张主表，一张副表，主要查询主表之中的数据，捎带着查询副表，当副表之中没有和主表中的数据匹配上，副表将模拟出 NULL 与之匹配**



#### 分类

1. 左外连接（左连接）：表示 **left关键字** 左边的这一张表是主表
2. 右外连接（右连接）：表示 **right关键字** 右边的这一张表是主表



**需要注意的是：左连接有有连接的写法，右连接有左连接的写法；实际上就是使用left关键字时，主表放在前面，等量的使用right关键字时，主表放到后面去，其它的一概不用改**





#### 实例

**找每个员工的上级领导（要求显示所有员工的领导，包含KING)**

```sql
# 左连接写法
select
  e1.ename '员工', e2.ename '领导'
from
  emp e1
  # 这里使用的是外查询， outer 关键字可以省略，是因为区分 内外连接 只需要看left,right关键字即可
  # left outer join emp e2
  left join emp e2
    on e1.mgr = e2.empno
order by e1.ename;

# 等效的右连接写法
select
  e1.ename '员工', e2.ename '领导'
from
  emp e2 
  right join emp e1 # 仅仅需要改这两句即可
    on e1.mgr = e2.empno
order by e1.ename;


# 查询结果
# 员工     领导  
# ------  --------
# ADAMS   SCOTT   
# ALLEN   BLAKE   
# BLAKE   KING    
# CLARK   KING    
# FORD    JONES   
# JAMES   BLAKE   
# JONES   KING    
# KING    (NULL)  
....

# 可以看到，相比之前的查询结果，这里多了 KING 它的领导是NULL
# 在实际开发过程之中，我们使用外连接比较多。因为不能因为没有与之匹配的数据就把原来的数据丢弃掉，这明显不是恰当的做法
```



#### 三张表连接

案例：**找出每个员工的工资等级及部门名称**

```sql
# 多张表连接的语法
...
A
join
B
on
...   # 先将A与B连接再将他们连接的结果与C进行连接
join
C
on
...

# 要求：找出每个员工的工资等级及部门名称
# 问题拆解：
# 1. 找出员工的工资等级
# 2. 找出员工的部门名称
# 3. 联合显示
select
  e.ename '员工', s.grade '工资等级', d.dname '部门'
from
  emp e
  left join salgrade s
    on e.sal between s.losal and s.hisal
  left join dept d
    on e.deptno = d.deptno;
 
# 查询结果
# 员工     工资等级       部门      
# ------  ------------  ------------
# SMITH              1  RESEARCH    
# ALLEN              3  SALES       
# WARD               2  SALES       
# JONES              4  RESEARCH    
....
```







## 子查询

定义：select 语句之中嵌套select语句，被嵌套的select语句是子查询

### 可以出现的位置

```sql
select
	...(select)
from
	...(select)
where
	...(select)
```



### where 语句之中使用子查询

**where语句之中利用子查询一般用于：子查询返回单个结果的情况**

案例：**找出薪资高于公司平均工资的员工信息**

```sql
# 拆解问题
# 1. 找出公司平均工资
select avg(sal) from emp;
# 2. 找出薪资比平均工资高的员工信息
select * from emp where sal > 公司平均工资;
# 3. 整合
select * from emp where sal > (select avg(sal) from emp);
```





### from 后面用子语句

使用场景：**一般子查询返回的是一张表，然后再在这张表基础之中进行查询**



案例1：**找出每个岗位平均薪资的薪资等级**

```sql
# 问题拆解
# 1. 找出每个岗位的平均薪资
select job,avg(job) avgsal from emp group by job;
# 2. 根据平均薪资获取对应的薪资等级
select grade from salgrade where 薪资 between losal and hisal;
# 3. 整合
 select
  t.job, t.avgsal, s.grade
from
  (select
    job, avg(sal) avgsal
  from
    emp
  group by job) t
  join salgrade s
    on t.avgsal between s.losal and s.hisal; 
```



**需要注意的是，虽然在from后面使用子查询，一般都是将子查询结果看成一张临时表，但不要什么时候都直接把子查询直接复制过去，起个别名就使用，没必要**



案例2：**找出每个岗位的员工的薪资等级的平均值**

```sql
# 问题拆分
# 1. 找出每个岗位的员工的薪资等级
select e.ename,e.job,e.sal,s.grade
from emp e
join salgrade s
on e.sal between s.losal and s.hisal;
# 2. 在以上数据基础之中，求平均值
select e.job,avg(s.grade)
from emp e
join salgrade s
on e.sal between s.losal and s.hisal
group by job;
# 这里可以直接接着写条件是因为那些数据都是已经存在的，可以直接得出结果
```





### select 语句后前嵌套子查询

案例：**找出每个员工的部门名称，要求显示员工名和部门名**

```sql
# 常规写法
select e.ename '员工名',d.dname '部门名'
from emp e
join dept d
on e.deptno=d.deptno;

# 子查询，不要求会写，看得懂就行
select
  e.ename,
  (select
    d.dname
  from
    dept d
  where e.deptno = d.deptno) as dname
from
  emp e;
```





## union关键字

**作用：可以将 <u>列数相同</u> 的结果集相加**

```sql
# 案例：找出部门编号是20和30的员工信息

# 写法一：使用 or
select * from emp where deptno=20 or deptno=30;

# 写法二：使用 in
select * from emp where deptno in (20,30);

# 写法三：使用 union
select * from emp where deptno=20;
union
select * from emp where deptno=30;
# 需要说明的是，使用 union 是将上面两个的结果集相加，
# 可以看到写法一、二和写法三的结果排列顺序是不一样的

#  写法一、二查询结果
-- ename   deptno  
-- ------  --------
-- SMITH         20
-- ALLEN         30
-- WARD          30
-- JONES         20
....

#  写法三查询结果
-- ename   deptno  
-- ------  --------
-- SMITH         20
-- JONES         20
-- SCOTT         20
-- ADAMS         20
-- FORD          20
-- ALLEN         30
-- WARD          30
....
```



**与使用or或者in相比，union可以连接毫无关系的两个结果集，虽然可能连接结果没有意义，但只要列数相同就可以连接**



```sql
select ename '混合列' from emp
union
select dname from dept;

#  结果名字取决于union前面字段的名字
#  查询结果
-- 混合列   
-- ------------
-- SMITH       
-- ALLEN       
-- WARD        
-- JONES       
....

# 列数不同时，会报错
select ename,job '混合列' from emp
union
select dname from dept;
# 报错信息：
# The used SELECT statements have a different number of columns
```



## limit 分页查询及标准分页

1. **limit 是MySql之中特有的，其他数据库管理系统没有，不通用**
2. **limit 是取结果集之中的部分数据**



### 语法规则

```sql
limit startIndex, length;
# startIndex 表示显示的第一个数据的编号，从0开始，当 startIndex 不写时，默认为 0
# length     表示查询数据个数

# 案例：取出工资前五名
select * from emp limit 0, 5;
# 当 startIndex 是 0 时可以缺省不写，这两条语句等效
select * from emp limit 5;
```



### 查询语句执行顺序

```sql
select
	...		5
from
	...		1
where
	...		2
group by
	...		3
having
	...		4
order by
	...		6
limit
	...		7 # 对查询出的结果集进行限制显示行数
```



### 通用标准分页sql

案例：**要求每页显示10条数据，只显示第 n 页的 limit 语句怎么写**

```sql
# 查询 第 pageNumber 页的数据，要求每页显示 numberOfRecordsPerPage 条数据
... limit (pageNumber - 1)*numberOfRecordsPerPage, numberOfRecordsPerPage;
```





## 常见数据类型

| 数据类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| int      | 整型(对应Java之中的int)                                      |
| bigint   | 长整型(对应Java之中的long)                                   |
| folat    | 浮点型(对应Java之中的flolat,double)                          |
| char     | 定长字符串(对应Java之中的String)                             |
| varchar  | 不定长字符串(对应Java之中的StringBuilder和StringBuffer)(最长255) |
| date     | 日期(对应Java之中的java.sql.Date)                            |
| BLOB     | 二进制大对象(存储图片、视频等流媒体信息) Binary Large OBject，必须用IO流插入 |
| CLOB     | 字符大对象(存储较大文本，比如，可以存储4G的字符串) Character Large OBject |



### char 和 varchar 的选择

**内存分配特点：**

char(n)，**不管实际数据长度，直接分配n位对应的空间**；

varchar(n)，**会动态分配空间，按照实际情况分配**



 一个示例表

| name   | sex               |
| ------ | :---------------- |
| Mikael | 男（可以用1表示） |
| Mary   | 女（可以用0表示） |


```sql
cerate table t_stu(
	# name char(6), 即使是插入第二条记录，名字只有4位时，也会分配6位char需要的空间，空间浪费
    name varchar(6), # 自动判断，动态分配空间，不会造成浪费，但会影响效率
    # 名字是不定长的，使用varchar比较好
    sex cahr(1), # 只有一位，固定位数，使用char比较好
);
```

**实际开发之中，但某字段数据长度不发生改变，是定长时，可以采用char，例如性别、生日等**

**而像一些经常不确定长度的数据，通常采用varchar，char效率比较高，不需要进行判断，varchar需要进行判断**







## 建立表格

**表名约定规范：表名在数据库之中一般建议以：t_ 或者 tbl_ + 实际表名**

建表语句

```sql
create table 表名( 
    字段1 数据类型, # 要求字段名见名知义，即含义明确
    字段2 数据类型, # 主要难点在于选择合适的数据结果，根据最小需求原则选或者安全等原则
    字段3 数据类型,
    ....
);

create table t_stu(
	no    int(4),
    name  varchar(10),
    sex   char(1),
    grade char(10)
);
```





## 插入数据

**语法：insert into 表名(字段1, 字段2, 字段3 ...) values (值1, 值2, 值3...);**

**这里只需要字段的位置与后面的值位置对应即可，可以修改成以下写法**

**insert into 表名(字段2, 字段1, 字段3 ...) values (值2, 值1, 值3...);**

上面两句是等效的语句

```sql
# 向我们刚刚创建的表格之中插入数据
insert into t_stu (no, name, sex, grade)
values
  (1, 'zhangsan', '1', 'gaosan2ban');

# 调换字段顺序和子值顺序
insert into t_stu (name, no, sex, grade)
values
  ('lisi', 2, '0', 'gaosan3ban');

# 可以省略一些字段，当某一字段被省略时会自动向该字段插入字段默认值，没设置则为NULL
insert into t_stu (name, sex, grade)
values
  ('wangwu', '1', 'gaosan2ban');
insert into t_stu (name, sex)
values
  ('qianliu', '0');

# select * from t_stu;
# 查询结果如下：
#     no  name      sex     grade       
# ------  --------  ------  ------------
#      1  zhangsan  1       gaosan2ban  
#      2  lisi      0       gaosan3ban  
# (NULL)  wangwu    1       gaosan2ban  
# (NULL)  qianliu   0       (NULL)       
  
# 前面的字段可以省略，这时后面的值的顺序和数量必须和表的格式一致。当不一致时会报错
# 报错信息：Column count doesn't match value count at row 1
insert into t_stu # (name, no, sex, grade)
values
  ('lisi', 2, '0', 'gaosan3ban');
 
# 查询结果：
#     no  name      sex     grade       
# ------  --------  ------  ------------
#      1  zhangsan  1       gaosan2ban  
#      2  lisi      0       gaosan3ban  
# (NULL)  wangwu    1       gaosan2ban  
# (NULL)  qianliu   0       (NULL)      
#      7  liuqi     0       gaosan7ban  

# 一次可以插入多条记录
insert into t_stu
values
  (2, 'lisi', '0', 'gaosan3ban'),
  (3, 'laotie', '1', 'gaosan2ban'),
  ...;
```



**需要注意：一旦一条insert语句执行成功，必然有一条记录被插入到表格之中，即使这条记录的某些字段可能是NULL，只能在后期通过update进行更新**

```sql
insert into t_stu (name, sex, grade)
values
  ('zhaoba', '0', 'gaosan1ban');
# 虽然上面这条语句插入的记录之中，no字段是NULL，不能通过下面这条语句更新
insert into t_stu (no)
values (8);

# 执行完上面两条语句之后，表格查询结果：
#     no  name      sex     grade       
# ------  --------  ------  ------------
#      1  zhangsan  1       gaosan2ban  
#      2  lisi      0       gaosan3ban  
# (NULL)  wangwu    1       gaosan2ban  
# (NULL)  qianliu   0       (NULL)      
#      7  liuqi     0       gaosan7ban  
# (NULL)  zhaoba    0       gaosan1ban  
#      8  (NULL)    (NULL)  (NULL)    
# 可以看到是多了两条记录，而不是把两条记录进行了融合
```



### 复制表格

```sql
# 表的复制语法：
# create table 表名 as DQL语句
# 将查询结果作为一张新的表
create table emp1 as select * from emp;

# 将DQL语句查询结果添加到现有表格之中
# insert into 表名 DQL语句
insert into emp1 select * from emp where deptno=10;

# 需要注意的是：将查询结果插入到目标表时，查询结果的列数需要和目标表列数一致。否则会报错
insert into emp1 select ename from emp where deptno=10;
# 报错信息：错误代码： 1136 Column count doesn't match value count at row 1
```



## 修改数据

**语法：update 表名 set 字段1=值1, 字段2=值2, 字段3=值3.. where 条件**

**需要注意：不添加条件，会将字段所有值修改，并且字段与字段之间使用逗号分隔**

```sql
create table emp1 select ename,deptno from emp where deptno in (10,20);
select * from emp1;
update emp1 set deptno=50 where deptno=10;
select * from emp1;
update emp1 set ename='x';
select * from emp1;

#  复制表
-- ename   deptno
-- ------  --------
-- SMITH         20
-- JONES         20
-- CLARK         10
-- SCOTT         20
-- KING          10
-- ADAMS         20
-- FORD          20
-- MILLER        10

#  更新 deptno字段 10 为 50
-- ename   deptno
-- ------  --------
-- SMITH         20
-- JONES         20
-- CLARK         50
-- SCOTT         20
-- KING          50
-- ADAMS         20
-- FORD          20
-- MILLER        50

#  不设置条件，更新整个字段的值为指定值
-- ename   deptno
-- ------  --------
-- x             20
-- x             20
-- x             50
-- x             20
-- x             50
-- x             20
-- x             20
-- x             50
```







## 删除表中数据

**语法：delete from 表名 where 条件**

**需要注意：和前面修改数据一样，不加条件会直接删除全部数据**

**<u>同时，delete是一个安全操作，可以进行回滚，不会释放空间，因此这样的删除操作较为耗费时间</u>**

```sql
delete from emp1 where deptno=10;
# 上述语句删除emp1表之中，deptno=10的记录
delete from emp1;
# 上述语句删除emp1表之中的全部记录
```



### 删除大表之中的数据

**上面提到，使用delete删除数据较为花费时间，这里介绍一种新的删除大表之中数据的方法，使用truncate语法，截断，即把表头和下面的数据截断**

**语法：truncate table 表名**

**注意：此操作不可进行回滚，一经删除，即数据消除，一定要问清楚是确定数据不需要了才能使用这样方式删除数据**

```sql
truncate table emp1;
```





## 修改表的结构

**用工具完成即可，在实际开发过程之中，几乎不会出现，会在建表时仔细考虑**



CRUD：Create(创建)、Retrieve(检索)、Update(更新)、Delete(删除)



## 约束

**约束的作用：在建立表时，给字段添加约束，目的是，保证数据的合法性、完整性、有效性**

**常见约束：**

| 约束名                    | 约束描述                                                     |
| ------------------------- | ------------------------------------------------------------ |
| **非空约束(not null)**    | **约束字段值不能为NULL**                                     |
| **唯一约束(unique)**      | **约束字段值不能出现重复**                                   |
| **主键约束(primary key)** | **约束字段值既不为NULL，也不能重复**                         |
| **外键约束(foreign key)** | **进行引用约束，约束子表引用字段不能出现父表之中的被引用字段没有的值** |
| 检查约束(check)           | Oracle专属，MySQL 没有                                       |





### not null

**非空约束：被约束的字段不能为NULL**

```sql
drop table if exists t_stu;
create table t_stu(
	id int not null,
    name varchar(255) 
);

# 当字段为非空字段时除非添加了default 语句设置了默认值，否则在插入数据时，不可省略
insert into t_stu(name) values ('zs');
# 报错 错误代码： 1364 Field 'id' doesn't have a default value

drop table if exists t_stu;
create table t_stu(
	id int not null default 1,
    name varchar(255) 
);

# 上述添加了default 语句设置了默认值，在插入数据时，可省略非空约束字段的定义
insert into t_stu(name) values ('zs');
# 上面这条语句执行时不报错
```





### 唯一约束

**唯一性约束：被修饰的字段的值不能重复，当可以多个值同时为NULL，因为NULL不是一个值，不算重复**



**案例：给单列添加unique**

```sql
drop table if exists t_user;
create table t_user(
	id int,
    name varchar(255) unique 
);
insert into t_user(id,name) values (1,'zs');
insert into t_user(id,name) values (2,'zs');
# 第二句就会报错，因为字段name添加了唯一性约束，字段值不能相等
# 报错信息：错误代码： 1062 Duplicate entry 'zs' for key 'name'
```



**案例：给两个列或者多个列添加unique**

```sql
drop table if exists t_user;
create table t_user(
	id int,
    name varchar(255),
    email varchar(255),
    unique(id,name)  # 表级约束
);
insert into t_user(id,name,email) values (1,'zs','zs@abc.com');
insert into t_user(id,name,email) values (2,'ls','ls@abc.com');
insert into t_user(id,name) values (2,'ls','ww@abc.com');
# 第三句才会报错，因为字段id和name联合字段添加了唯一性约束，第二句没有重复，第三句和第二句联合的唯一性字段重复了，所以不能够添加成功
# 报错信息：错误代码： 1062	Duplicate entry '2-ls' for key 'id'


# 这种联合的唯一性约束需要区别于两个字段都加约束
drop table if exists t_user;
create table t_user(
	id int unique,   # 行级约束
    name varchar(255) unique,
    email varchar(255),
);
insert into t_user(id,name,email) values (1,'zs','zs@abc.com');
insert into t_user(id,name) values (2,'zs','ls@abc.com');
# 这里第二句就会报错，原因是 name 字段也是唯一性约束的，不能够重复
```





## 主键约束

**需要注意：一张表只能有一个主键**

**怎么添加主键约束，主键约束有什么用？**

```sql
drop table if exists t_user;
create table t_user(
	id int primary key, # 行级约束
    username varchar(255),
    email varchar(255)
);
insert into t_user(is,username,email) values (1,'jack','jack@abc.com');
insert into t_user(is,username,email) values (1,'rose','rose@abc.com');
# 错误代码： 1062 Duplicate entry '1' for key 'PRIMARY'
# 主键字段具有唯一性

insert into t_user(username,email) values ('mary','mary@abc.com');
# 错误代码： 1364 Field 'id' doesn't have a default value
# 主键字段具有非空性
```



**主键相关术语：**

**主键约束：primary key**

**主键字段：添加了主键约束的字段叫做主键字段**

**主键值：主键字段的值**



**主键有什么用？表的设计三范式之中有要求，第一范式就要求任何一张表之中应当有主键**

**主键作用：一行记录在一个表之中具有一个唯一标识符那就是主键。主键不一样则为不同的记录，类似身份证号码**



### 主键分类

1. 根据主键字段数量来分
   1. 单一主键（推荐）
   2. 复合主键（不推荐）多个字段联合起来添加一个主键，违背三范式
2. 根据主键性质来分
   1. 自然主键（推荐）：使用自然数来当主键
   2. 业务主键（不推荐）：主键值与业务挂钩，比如使用身份证号来当主键
      1. **最好不要使用和业务挂钩的字段作为主键，因为以后业务一旦发生改变的时候，可能主键值也随之改变，但有时往往没有办法改变，因为改变后可能导致主键的值重复**



### 自增的自然主键

**MySQL提供了一个让主键值自增的修饰符 auto_increment**

```sql
# 使用auto_increment 定义自然增长的主键
drop table if exists t_user;
create table t_user(
	id int primary key auto_increment,
    username varchar(255)
);

insert into t_user(username) values ('zs');
insert into t_user(username) values ('ls');
insert into t_user(username) values ('ww');
insert into t_user(username) values ('ql');
select * from t_user;

# 查询结果如下
--     id  username  
-- ------  ----------
--      1  zs        
--      2  ls        
--      3  ww        
--      4  ql        
```







## 外键约束

**业务背景：设计数据库，维护学生和班级的信息**

1. 使用一张表存储所有数据

   ```sql
   # 表
   sno  sname classno classname
   -----------------------------
   1	 zs	   1       gaosan1ban
   2	 ls	   2       gaosan2ban
   3	 ww	   1       gaosan1ban
   # 可以解决问题，但是重复数据过多，数据冗余严重
   ```

   

2. 使用学生表和班级表来分别存储数据

   ```sql
   # 学生表
   sno  sname classno
   ------------------
   1	 zs	   1      
   2	 ls	   2      
   3	 ww	   1    
   4    ql    3
   
   # 班级表
   classno classname
   -----------------
   1		gaosan1ban
   2		gaosan2ban
   
   # 当没加外键约束时，学生表之中的classno可以随便写，加了外键约束后，只能取有限的一些值
   ```



**外键语法：foreign key(字段1) references 父表(字段2)**

**这样将字段1与字段2关联起来，字段一的值只能取字段2之中有的值，NULL也是允许的**

**需要注意：父表之中的字段2必须被唯一性约束，但不一定需要为主键**

引用字段和被引用字段都能为NULL，但似乎这样没有什么意义。

```sql
drop table if exists t_class;
create table t_class(
    classno int unique, # 被外键引用的字段必须添加唯一性约束
    classname varchar(255) unique
);
drop table if exists t_stu;
create table t_stu(
	sno int,
    sname varchar(255),
    classno int,
    foreign key(classno) references t_class(classno)
);
# 建表：先建父表，再建子表
insert into t_class values(1,'gaosan1ban');
insert into t_class values(2,'gaosan2ban');
insert into t_stu values(1,'zhangsan',1);
insert into t_stu values(2,'lisi',2);
# 插入数据：先插入父表，再插入子表
# 当插入子表数据，父表中没有与之对应的项时，会报错
insert into t_stu values(3,'wangwu',3);
# 错误代码： 1452 
# Cannot add or update a child row: a foreign key constraint fails (`su`.`t_stu`,  # CONSTRAINT `t_stu_ibfk_1` FOREIGN KEY (`classno`) REFERENCES `t_class` 
# (`classno`))
# 无法添加或更新子行：外键约束失败
```





## 事务

**定义：一个完整的业务逻辑单元，不可再分。**

比如：银行转账，从账户A转给账户B10000元，需要执行以下两条update语句

```sql
update t_act set balance=balance-10000 where actno='actno-001';
update t_act set balance=balance+10000 where actno='actno-002';
```

**以上两条语句必须同时成功，或者同时失败，不允许出现一条成功，一条失败**

**要实现上面的功能，就必须采用事务机制**



1. **和事务相关的只有DML语句：insert delete update （数据相关）**

2. **事务作用：保证数据的完整性、安全性**
3. **单个DML语句不需要事务机制，通常一个业务需要多个DML语句完成**



### 事务的原理

1. **开始事务机制（开始）**
2. **执行insert .... -> insert ... 执行成功时，把这条执行记录放入到数据库的操作记录历史之中，并不修改文件数据**
3. **执行delete .... -> delete ... 执行成功时，把这条执行记录放入到数据库的操作记录历史之中，并不修改文件数据**
4. **提交事务或回滚事务（结束）**

**提交则把操作记录同步到本地的文件之中，然后清空历史**

**回滚则直接清空历史，不进行保存**



### 事务的特性

**ACID**

ACID是原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）的缩写，这四种状态的意思是：

**1、原子性**

即不可分割，事务要么全部被执行，要么全部不执行。如果事务的所有子事务全部提交成功，则所有的数据库操作被提交，数据库状态发生变化；如果有子事务失败，则其他子事务的数据库操作被回滚，即数据库回到事务执行前的状态，不会发生状态转换

**2、一致性**

事务的执行使得数据库从一种正确状态转换成另外一种正确状态

**3、隔离性**

在事务正确提交之前，不允许把事务对该数据的改变提供给任何其他事务，即在事务正确提交之前，它可能的结果不应该显示给其他事务

**4、持久性**

事务正确提交之后，其结果将永远保存在数据库之中，即使在事务提交之后有了其他故障，事务的处理结果也会得到保存



**并发下事务会产生的问题**

举个例子，事务A和事务B操纵的是同一个资源，事务A有若干个子事务，事务B也有若干个子事务，事务A和事务B在高并发的情况下，会出现各种各样的问题。"各种各样的问题"，总结一下主要就是五种：第一类丢失更新、第二类丢失更新、脏读、不可重复读、幻读。五种之中，第一类丢失更新、第二类丢失更新不重要，不讲了，讲一下脏读、不可重复读和幻读。

**1、脏读**

所谓脏读，就是指**事务A读到了事务B还没有提交的数据**，比如银行取钱，事务A开启事务，此时切换到事务B，事务B开启事务-->取走100元，此时切换回事务A，事务A读取的肯定是数据库里面的原始数据，因为事务B取走了100块钱，并没有提交，数据库里面的账务余额肯定还是原始余额，这就是脏读。

**2、不可重复读**

所谓不可重复读，就是指**在一个事务里面读取了两次某个数据，读出来的数据不一致**。还是以银行取钱为例，事务A开启事务-->查出银行卡余额为1000元，此时切换到事务B事务B开启事务-->事务B取走100元-->提交，数据库里面余额变为900元，此时切换回事务A，事务A再查一次查出账户余额为900元，这样对事务A而言，在同一个事务内两次读取账户余额数据不一致，这就是不可重复读。

**3、幻读**

所谓幻读，就是指**在一个事务里面的操作中发现了未被操作的数据**。比如学生信息，事务A开启事务-->修改所有学生当天签到状况为false，此时切换到事务B，事务B开启事务-->事务B插入了一条学生数据，此时切换回事务A，事务A提交的时候发现了一条自己没有修改过的数据，这就是幻读，就好像发生了幻觉一样。幻读出现的前提是并发的事务中有事务发生了插入、删除操作。

[一个详细解析的博客](https://www.cnblogs.com/snsdzjlz320/p/5761387.html)



### 一些命令

```sql
# 查看系统当前隔离等级
select @@global.tx_isolation;

# 设置隔离等级
set global transaction isolation level [read uncommitted、read committed、repeatable read、serializable]
```



























































